<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="这里主要坦述MD5和AES的流程分析。 这两种代表了目前最主流的加密组合。 MD5聊起md5，许多开发人员用这个的目的，做个hash值，api签名加个密，密码md5…. 散列函数散列函数，也称作哈希函数，消息摘要函数，单向函数或者杂凑函数。散列函数主要用于验证数据的完整性。通过散列函数，可以创建消息的“数字指纹”，消息接收方可以通过校验消息的哈希值来验证消息的完整性，防止消息被篡改。散列函数具有以">
<meta property="og:type" content="article">
<meta property="og:title" content="通用加密算法解析和魔改">
<meta property="og:url" content="http://chionyuan.github.io/2022/07/19/common-algorithm/index.html">
<meta property="og:site_name" content="一只想登珠峰的猪">
<meta property="og:description" content="这里主要坦述MD5和AES的流程分析。 这两种代表了目前最主流的加密组合。 MD5聊起md5，许多开发人员用这个的目的，做个hash值，api签名加个密，密码md5…. 散列函数散列函数，也称作哈希函数，消息摘要函数，单向函数或者杂凑函数。散列函数主要用于验证数据的完整性。通过散列函数，可以创建消息的“数字指纹”，消息接收方可以通过校验消息的哈希值来验证消息的完整性，防止消息被篡改。散列函数具有以">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://chionyuan.github.io/images/pasted-4.png">
<meta property="og:image" content="http://chionyuan.github.io/images/pasted-3.png">
<meta property="og:image" content="http://chionyuan.github.io/images/pasted-5.png">
<meta property="og:image" content="http://chionyuan.github.io/images/pasted-6.png">
<meta property="og:image" content="http://chionyuan.github.io/images/pasted-7.png">
<meta property="og:image" content="http://chionyuan.github.io/images/pasted-8.png">
<meta property="og:image" content="http://chionyuan.github.io/images/pasted-10.png">
<meta property="og:image" content="http://chionyuan.github.io/images/pasted-11.png">
<meta property="og:image" content="http://chionyuan.github.io/images/pasted-12.png">
<meta property="og:image" content="http://chionyuan.github.io/images/pasted-13.png">
<meta property="og:image" content="http://chionyuan.github.io/images/pasted-14.png">
<meta property="og:image" content="http://chionyuan.github.io/images/pasted-15.png">
<meta property="article:published_time" content="2022-07-19T01:46:35.902Z">
<meta property="article:modified_time" content="2022-07-19T03:49:31.433Z">
<meta property="article:author" content="chionyuan">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://chionyuan.github.io/images/pasted-4.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>通用加密算法解析和魔改</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.2.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/secguide/">移动安全</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/chionyuan">项目</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2022/07/18/ollvm_1/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://chionyuan.github.io/2022/07/19/common-algorithm/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://chionyuan.github.io/2022/07/19/common-algorithm/&text=通用加密算法解析和魔改"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://chionyuan.github.io/2022/07/19/common-algorithm/&title=通用加密算法解析和魔改"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://chionyuan.github.io/2022/07/19/common-algorithm/&is_video=false&description=通用加密算法解析和魔改"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=通用加密算法解析和魔改&body=Check out this article: http://chionyuan.github.io/2022/07/19/common-algorithm/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://chionyuan.github.io/2022/07/19/common-algorithm/&title=通用加密算法解析和魔改"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://chionyuan.github.io/2022/07/19/common-algorithm/&title=通用加密算法解析和魔改"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://chionyuan.github.io/2022/07/19/common-algorithm/&title=通用加密算法解析和魔改"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://chionyuan.github.io/2022/07/19/common-algorithm/&title=通用加密算法解析和魔改"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://chionyuan.github.io/2022/07/19/common-algorithm/&name=通用加密算法解析和魔改&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://chionyuan.github.io/2022/07/19/common-algorithm/&t=通用加密算法解析和魔改"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#MD5"><span class="toc-number">1.</span> <span class="toc-text">MD5</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.0.1.</span> <span class="toc-text">散列函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MD5%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.</span> <span class="toc-text">MD5算法原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%A1%AB%E5%85%85%E4%BF%A1%E6%81%AF"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.填充信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86"><span class="toc-number">1.1.2.</span> <span class="toc-text">2.信息处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#md5%E7%AE%97%E6%B3%95%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">md5算法过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MD5%E5%88%86%E6%9E%90%E5%92%8C%E9%AD%94%E6%94%B9"><span class="toc-number">1.3.</span> <span class="toc-text">MD5分析和魔改</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#md5%E4%BF%AE%E6%94%B9%E7%82%B9"><span class="toc-number">1.4.</span> <span class="toc-text">md5修改点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AES"><span class="toc-number">2.</span> <span class="toc-text">AES</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC-AES-%E5%8A%A0%E5%AF%86"><span class="toc-number">2.1.</span> <span class="toc-text">基本 AES 加密</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AES%E5%8A%A0%E5%AF%86%E6%B5%81%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">AES加密流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AEST%E8%A1%A8"><span class="toc-number">2.3.</span> <span class="toc-text">AEST表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AES-%E6%9F%A5%E6%89%BE%E8%A1%A8-T-Table-%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.1.</span> <span class="toc-text">AES 查找表 (T-Table) 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E8%A1%A8%E7%94%9F%E6%88%90"><span class="toc-number">2.3.2.</span> <span class="toc-text">查找表生成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E5%90%88%E5%8A%A0%E5%AF%86"><span class="toc-number">2.3.3.</span> <span class="toc-text">回合加密</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%90%8E%E4%B8%80%E8%BD%AE"><span class="toc-number">2.3.4.</span> <span class="toc-text">最后一轮</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AES-T-%E8%A1%A8-Python-%E4%BB%A3%E7%A0%81"><span class="toc-number">2.3.5.</span> <span class="toc-text">AES T 表 Python 代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AES%E5%88%86%E6%9E%90%E5%92%8C%E9%AD%94%E6%94%B9"><span class="toc-number">2.4.</span> <span class="toc-text">AES分析和魔改</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        通用加密算法解析和魔改
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">chionyuan</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2022-07-19T01:46:35.902Z" itemprop="datePublished">2022-07-19</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/%E9%80%86%E5%90%91/">逆向</a>
    </div>


      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>这里主要坦述MD5和AES的流程分析。</p>
<p>这两种代表了目前最主流的加密组合。</p>
<h1 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h1><p>聊起md5，许多开发人员用这个的目的，做个hash值，api签名加个密，密码md5….</p>
<h4 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h4><p>散列函数，也称作哈希函数，消息摘要函数，单向函数或者杂凑函数。散列函数主要用于验证数据的完整性。通过散列函数，可以创建消息的“数字指纹”，消息接收方可以通过校验消息的哈希值来验证消息的完整性，防止消息被篡改。散列函数具有以下特性：</p>
<ol>
<li>散列函数的运算过程是不可逆的，这个称为散列函数的单向性。</li>
<li>对于一个已知的消息及其散列值，要找到另外一个消息使其获得相同的散列值是不可能的，这个特性称为散列函数的弱碰撞性。这个特性可以用来防止消息伪造。</li>
<li>任意两个不同消息的散列值一定不同。</li>
<li>对原始消息长度没有限制。</li>
</ol>
<p>任何消息经过散列函数处理后，都会产生一个唯一的散列值，这个散列值可以用来验证消息的完整性。计算消息散列值的过程被称为“消息摘要”，计算消息散列值的算法被称为消息摘要算法。常使用的消息摘要算法有：MD—消息摘要算法，SHA—安全散列算法，MAC—消息认证码算法。本文主要来了解MD算法。</p>
<h2 id="MD5算法原理"><a href="#MD5算法原理" class="headerlink" title="MD5算法原理"></a>MD5算法原理</h2><p>假设原始消息长度是b（以bit为单位），注意这里b可以是任意长度，并不一定要是8的整数倍。计算该消息MD5值的过程如下：</p>
<h3 id="1-填充信息"><a href="#1-填充信息" class="headerlink" title="1.填充信息"></a>1.填充信息</h3><p>在计算消息的MD5值之前，首先对原始信息进行填充，这里的信息填充分为两步。<br> 第一步，对原始信息进行填充，填充之后，要求信息的长度对512取余等于448。填充的规则如下：假设原始信息长度为b bit，那么在信息的b+1 bit位填充1，剩余的位填充0，直到信息长度对512取余为448。这里有一点需要注意，如果原始信息长度对512取余正好等于448，这种情况仍然要进行填充，很明显，在这时我们要填充的信息长度是512位，直到信息长度对512取余再次等于448。所以，填充的位数最少为1，最大为512。<br> 第二步，填充信息长度，我们需要把原始信息长度转换成以bit为单位，然后在第一步操作的结果后面填充64bit的数据表示原始信息长度。第一步对原始信息进行填充之后，信息长度对512取余结果为448，这里再填充64bit的长度信息，整个信息恰好可以被512整除。其实从后续过程可以看到，计算MD5时，是将信息分为若干个分组进行处理的，每个信息分组的长度是512bit。</p>
<h3 id="2-信息处理"><a href="#2-信息处理" class="headerlink" title="2.信息处理"></a>2.信息处理</h3><p>在进行MD5值计算之前，我们先来做一些定义。</p>
<ul>
<li><p><strong>信息分组定义</strong><br> 原始信息经过填充之后，最终得到的信息长度（bit）是512的整数倍，我们先对信息进行分组，每512bit为一个分组，然后再将每个信息分组（512bit）再细分为16个小的分组，每个小分组的长度为32bit。规定如下<br> Mp 代表经过填充之后的信息<br> LM 表示Mp的长度（以bit为单位）<br> N 表示分组个数，N &#x3D; LM&#x2F;512<br> M[i] 表示将原始信息进行分组后的第i个信息分组，其中i&#x3D;1…N<br> X[i] 表示将M[i]进行分组后的第i个小分组，其中i&#x3D;1…16</p>
</li>
<li><p><strong>标准幻数定义</strong><br> 现定义四个标准幻数如下，<br> A &#x3D; 01 23 45 67<br> B &#x3D; 89 ab cd ef<br> C &#x3D; fe dc ba 98<br> D &#x3D; 76 54 32 10<br> 在计算机中存储时，采用小端存储方式，以A为例，A在Java中初始化的代码为为A&#x3D;0x67452301</p>
</li>
<li><p><strong>常量表T</strong><br> T是一个常量表，T[i] &#x3D; 4294967296 * abs(sin(i))的运算结果取整，其中i&#x3D;1…64</p>
</li>
</ul>
<p><img src="/images/pasted-4.png" alt="upload successful"></p>
<ul>
<li><p><strong>辅助方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">我们定义四个辅助方法。</span><br><span class="line">F(x,y,z) = (x &amp; y) | ((~x) &amp; z)</span><br><span class="line">G(x,y,z) = (x &amp; z) | (y &amp; (~z))</span><br><span class="line">H(x,y,z) = x ^ y ^ z</span><br><span class="line"><span class="title function_">I</span><span class="params">(x,y,z)</span> = y ^ (x | (~z))</span><br><span class="line">其中，x，y，z长度为32bit</span><br></pre></td></tr></table></figure></li>
</ul>
<p>下面就是最核心的信息处理过程，计算MD5的过程实际上就是轮流处理每个信息分组的过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">    A=<span class="number">0x67452301</span></span><br><span class="line">    B=<span class="number">0xefcdab89</span></span><br><span class="line">    C=<span class="number">0x98badcfe</span></span><br><span class="line">    D=<span class="number">0x10325476</span></span><br><span class="line">    <span class="keyword">for</span>( j=<span class="number">1</span>;j&lt;=N;j++)&#123;  <span class="comment">//依次处理每个分组，其中N代表分组个数</span></span><br><span class="line">      AA = <span class="type">A</span> </span><br><span class="line">      <span class="variable">BB</span> <span class="operator">=</span> <span class="type">B</span> </span><br><span class="line">      <span class="variable">CC</span> <span class="operator">=</span> <span class="type">C</span></span><br><span class="line">      <span class="variable">DD</span> <span class="operator">=</span> D</span><br><span class="line">      <span class="comment">//开始处理分组，每个信息分组要经过4轮处理</span></span><br><span class="line">      <span class="comment">/*第一轮</span></span><br><span class="line"><span class="comment">      假设 [abcd k s i] 表示执行的运算是 a = b + ((a + F(b,c,d) + X[k] + T[i]) &lt;&lt;&lt; s)，其中&lt;&lt;&lt;表示循环移位。第一轮运算就是对分组执行以下所示的16次运算，运算的顺序从左到右。*/</span></span><br><span class="line">    [ABCD <span class="number">0</span> <span class="number">7</span> <span class="number">1</span>] [DABC <span class="number">1</span> <span class="number">12</span> <span class="number">2</span>] [CDAB <span class="number">2</span> <span class="number">17</span> <span class="number">3</span>] [BCDA <span class="number">3</span> <span class="number">22</span> <span class="number">4</span>]</span><br><span class="line">    [ABCD <span class="number">4</span> <span class="number">7</span> <span class="number">5</span>] [DABC <span class="number">5</span> <span class="number">12</span> <span class="number">6</span>] [CDAB <span class="number">6</span> <span class="number">17</span> <span class="number">7</span>] [BCDA <span class="number">7</span> <span class="number">22</span> <span class="number">8</span>]</span><br><span class="line">    [ABCD <span class="number">8</span> <span class="number">7</span> <span class="number">9</span>] [DABC <span class="number">9</span> <span class="number">12</span> <span class="number">10</span>] [CDAB <span class="number">10</span> <span class="number">17</span> <span class="number">11</span>] [BCDA <span class="number">11</span> <span class="number">22</span> <span class="number">12</span>]</span><br><span class="line">    [ABCD <span class="number">12</span> <span class="number">7</span> <span class="number">13</span>] [DABC <span class="number">13</span> <span class="number">12</span> <span class="number">14</span>] [CDAB <span class="number">14</span> <span class="number">17</span> <span class="number">15</span>] [BCDA <span class="number">15</span> <span class="number">22</span> <span class="number">16</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*第二轮</span></span><br><span class="line"><span class="comment">    假设 [abcd k s i] 表示执行的运算是 a = b + ((a + G(b,c,d) + X[k] + T[i]) &lt;&lt;&lt; s)，其中 &lt;&lt;&lt;表示循环移位。第一轮运算就是对分组执行以下所示的16次运算，运算的顺 序从左到右。*/</span></span><br><span class="line">    [ABCD <span class="number">1</span> <span class="number">5</span> <span class="number">17</span>] [DABC <span class="number">6</span> <span class="number">9</span> <span class="number">18</span>] [CDAB <span class="number">11</span> <span class="number">14</span> <span class="number">19</span>] [BCDA <span class="number">0</span> <span class="number">20</span> <span class="number">20</span>]</span><br><span class="line">    [ABCD <span class="number">5</span> <span class="number">5</span> <span class="number">21</span>] [DABC <span class="number">10</span> <span class="number">9</span> <span class="number">22</span>] [CDAB <span class="number">15</span> <span class="number">14</span> <span class="number">23</span>] [BCDA <span class="number">4</span> <span class="number">20</span> <span class="number">24</span>]</span><br><span class="line">    [ABCD <span class="number">9</span> <span class="number">5</span> <span class="number">25</span>] [DABC <span class="number">14</span> <span class="number">9</span> <span class="number">26</span>] [CDAB <span class="number">3</span> <span class="number">14</span> <span class="number">27</span>] [BCDA <span class="number">8</span> <span class="number">20</span> <span class="number">28</span>]</span><br><span class="line">    [ABCD <span class="number">13</span> <span class="number">5</span> <span class="number">29</span>] [DABC <span class="number">2</span> <span class="number">9</span> <span class="number">30</span>] [CDAB <span class="number">7</span> <span class="number">14</span> <span class="number">31</span>] [BCDA <span class="number">12</span> <span class="number">20</span> <span class="number">32</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*第三轮</span></span><br><span class="line"><span class="comment">    假设 [abcd k s i] 表示执行的运算是 a = b + ((a + H(b,c,d) + X[k] + T[i]) &lt;&lt;&lt; s)，其中&lt;&lt;&lt;表示循环移位。第一轮运算就是对分组执行以下所示的16次运算，运算的顺 序从左到右。*/</span></span><br><span class="line">    [ABCD <span class="number">5</span> <span class="number">4</span> <span class="number">33</span>] [DABC <span class="number">8</span> <span class="number">11</span> <span class="number">34</span>] [CDAB <span class="number">11</span> <span class="number">16</span> <span class="number">35</span>] [BCDA <span class="number">14</span> <span class="number">23</span> <span class="number">36</span>]</span><br><span class="line">    [ABCD <span class="number">1</span> <span class="number">4</span> <span class="number">37</span>] [DABC <span class="number">4</span> <span class="number">11</span> <span class="number">38</span>] [CDAB <span class="number">7</span> <span class="number">16</span> <span class="number">39</span>] [BCDA <span class="number">10</span> <span class="number">23</span> <span class="number">40</span>]</span><br><span class="line">    [ABCD <span class="number">13</span> <span class="number">4</span> <span class="number">41</span>] [DABC <span class="number">0</span> <span class="number">11</span> <span class="number">42</span>] [CDAB <span class="number">3</span> <span class="number">16</span> <span class="number">43</span>] [BCDA <span class="number">6</span> <span class="number">23</span> <span class="number">44</span>]</span><br><span class="line">    [ABCD <span class="number">9</span> <span class="number">4</span> <span class="number">45</span>] [DABC <span class="number">12</span> <span class="number">11</span> <span class="number">46</span>] [CDAB <span class="number">15</span> <span class="number">16</span> <span class="number">47</span>] [BCDA <span class="number">2</span> <span class="number">23</span> <span class="number">48</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*第四轮</span></span><br><span class="line"><span class="comment">    假设 [abcd k s i] 表示执行的运算是 a = b + ((a + I(b,c,d) + X[k] + T[i]) &lt;&lt;&lt; s)，其中&lt;&lt;&lt;表示循环移位。第一轮运算就是对分组执行以下所示的16次运算，运算的顺序从左到右。*/</span></span><br><span class="line">    [ABCD <span class="number">0</span> <span class="number">6</span> <span class="number">49</span>] [DABC <span class="number">7</span> <span class="number">10</span> <span class="number">50</span>] [CDAB <span class="number">14</span> <span class="number">15</span> <span class="number">51</span>] [BCDA <span class="number">5</span> <span class="number">21</span> <span class="number">52</span>]</span><br><span class="line">    [ABCD <span class="number">12</span> <span class="number">6</span> <span class="number">53</span>] [DABC <span class="number">3</span> <span class="number">10</span> <span class="number">54</span>] [CDAB <span class="number">10</span> <span class="number">15</span> <span class="number">55</span>] [BCDA <span class="number">1</span> <span class="number">21</span> <span class="number">56</span>]</span><br><span class="line">    [ABCD <span class="number">8</span> <span class="number">6</span> <span class="number">57</span>] [DABC <span class="number">15</span> <span class="number">10</span> <span class="number">58</span>] [CDAB <span class="number">6</span> <span class="number">15</span> <span class="number">59</span>] [BCDA <span class="number">13</span> <span class="number">21</span> <span class="number">60</span>]</span><br><span class="line">    [ABCD <span class="number">4</span> <span class="number">6</span> <span class="number">61</span>] [DABC <span class="number">11</span> <span class="number">10</span> <span class="number">62</span>] [CDAB <span class="number">2</span> <span class="number">15</span> <span class="number">63</span>] [BCDA <span class="number">9</span> <span class="number">21</span> <span class="number">64</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将当前消息分组的运算结果和上一次的结果进行累加</span></span><br><span class="line">    A = A + <span class="type">AA</span></span><br><span class="line">    <span class="variable">B</span> <span class="operator">=</span> B + <span class="type">BB</span></span><br><span class="line">    <span class="variable">C</span> <span class="operator">=</span> C + <span class="type">CC</span></span><br><span class="line">    <span class="variable">D</span> <span class="operator">=</span> D + DD</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最终我们按照低字节在前的顺序依次将A,B,C,D拼接起来，就是计算得到的MD5值，因此，MD5值的长度是固定的，为128bit。</span></span><br></pre></td></tr></table></figure>

<p>作者：咸鱼0907<br>链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/93a8ab5bfeb9">https://www.jianshu.com/p/93a8ab5bfeb9</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2 id="md5算法过程"><a href="#md5算法过程" class="headerlink" title="md5算法过程"></a>md5算法过程</h2><p>MD5以512位为一个分组处理输入，每个分组分成16个32位的子分组，经过处理后，输出四个32位分组，这四个32位分组级联后生成一个128位的MD5值。</p>
<p>一、填充：如果输入信息长度（以bit记）模512不余448，那就要对输入信息进行填充，填充一个1和若干个0，使得信息长度变成512<em>N+448，*<em>若消息长度本身即为448，仍要填充512位，使其长度变成960</em></em></p>
<p>二、记录：用64位记录输入信息的长度，然后添加到第一步的信息中，形成（N+1）*512的信息；</p>
<p>三、装入默认值：A&#x3D;0x01234567,B&#x3D;0x89ABCDEF,C&#x3D;0xFEDCBA98,D&#x3D;0x76543210。这里每个缓存均为32位（16进制四位，八个数）</p>
<p>四、分组：将512一组的数据进行分组，分成16个32位的子分组，将与幻数进行循环运算。</p>
<p>五、循环运算：这里借用一张MD5原理图进行说明</p>
<p><img src="/images/pasted-3.png" alt="upload successful"></p>
<h2 id="MD5分析和魔改"><a href="#MD5分析和魔改" class="headerlink" title="MD5分析和魔改"></a>MD5分析和魔改</h2><p>md5的源码，直接github上一搜一大把，就懒得copy了。<br>上文提到的4个东西</p>
<ol>
<li>信息分组定义</li>
<li>标准幻数定义</li>
<li>常量表T</li>
<li>辅助方法</li>
</ol>
<p>这四个东西都可以作为md5的特征，看看findcrypt这个插件，在ida中是如何识别md5算法的。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/polymorf/findcrypt-yara/blob/master/findcrypt3.rules">https://github.com/polymorf/findcrypt-yara/blob/master/findcrypt3.rules</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">rule MD5_Constants &#123;</span><br><span class="line">	meta:</span><br><span class="line">		author = <span class="string">&quot;phoul (@phoul)&quot;</span></span><br><span class="line">		description = <span class="string">&quot;Look for MD5 constants&quot;</span></span><br><span class="line">		date = <span class="string">&quot;2014-01&quot;</span></span><br><span class="line">		version = <span class="string">&quot;0.2&quot;</span></span><br><span class="line">	strings:</span><br><span class="line">		<span class="comment">// Init constants</span></span><br><span class="line">		$c0 = &#123; <span class="number">67452301</span> &#125;</span><br><span class="line">		$c1 = &#123; efcdab89 &#125;</span><br><span class="line">		$c2 = &#123; 98badcfe &#125;</span><br><span class="line">		$c3 = &#123; <span class="number">10325476</span> &#125;</span><br><span class="line">		$c4 = &#123; <span class="number">01234567</span> &#125;</span><br><span class="line">		$c5 = &#123; 89ABCDEF &#125;</span><br><span class="line">		$c6 = &#123; FEDCBA98 &#125;</span><br><span class="line">		$c7 = &#123; <span class="number">76543210</span> &#125;</span><br><span class="line">		<span class="comment">// Round 2</span></span><br><span class="line">		$c8 = &#123; F4D50d87 &#125;</span><br><span class="line">		$c9 = &#123; 78A46AD7 &#125;</span><br><span class="line">	condition:</span><br><span class="line">		<span class="number">5</span> of them</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rule MD5_API &#123;</span><br><span class="line">	meta:</span><br><span class="line">		author = <span class="string">&quot;_pusher_&quot;</span></span><br><span class="line">		description = <span class="string">&quot;Looks for MD5 API&quot;</span></span><br><span class="line">		date = <span class="string">&quot;2016-07&quot;</span></span><br><span class="line">	strings:</span><br><span class="line">		$advapi32 = <span class="string">&quot;advapi32.dll&quot;</span> wide ascii <span class="type">nocase</span></span><br><span class="line">		<span class="variable">$cryptdll</span> <span class="operator">=</span> <span class="string">&quot;cryptdll.dll&quot;</span> wide ascii <span class="type">nocase</span></span><br><span class="line">		<span class="variable">$MD5Init</span> <span class="operator">=</span> <span class="string">&quot;MD5Init&quot;</span> wide <span class="type">ascii</span></span><br><span class="line">		<span class="variable">$MD5Update</span> <span class="operator">=</span> <span class="string">&quot;MD5Update&quot;</span> wide <span class="type">ascii</span></span><br><span class="line">		<span class="variable">$MD5Final</span> <span class="operator">=</span> <span class="string">&quot;MD5Final&quot;</span> wide ascii</span><br><span class="line">	condition:</span><br><span class="line">		($advapi32 or $cryptdll) and ($MD5Init and $MD5Update and $MD5Final)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用标准幻数来识别的。</p>
<p>试着想想，在客户端暴露md5，或者直接在java层调用api的话，那么其实用任何语言的算法都能够实现。</p>
<p>此时又带来算法泄露的问题，有些大厂是把md5修改之后，直接编译器给vm了。这样在c层分析起来也特别困难。</p>
<h2 id="md5修改点"><a href="#md5修改点" class="headerlink" title="md5修改点"></a>md5修改点</h2><p>以上说的4处特征，都可以修改。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">信息分组定义：每次填充的值都是标准幻数，我们可以把<span class="number">16</span>个字节的幻数，填充成每次md5加密之后的结果。</span><br><span class="line">标准幻数定义：这是按照小端序来排列的，可以直接换成大端序。</span><br><span class="line">常量表T：T是一个常量表，T[i] = <span class="number">4294967296</span> * <span class="built_in">abs</span>(sin(i))的运算结果取整，其中i=<span class="number">1</span>…<span class="number">64</span>，</span><br><span class="line">				sin函数可以直接替换成cos函数。</span><br><span class="line">辅助方法：F,G,H,I 的算法依旧可以自己骚味修改修改。</span><br><span class="line">最后建议如果客户端的话，放在ndk或者dylib动态链接库中。</span><br></pre></td></tr></table></figure>



<h1 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h1><p>讲完了hash算法(不可逆)，来讲讲对称算法aes的作用。</p>
<p>这套算法在工作中也经常用，用来加密一些敏感信息….</p>
<h2 id="基本-AES-加密"><a href="#基本-AES-加密" class="headerlink" title="基本 AES 加密"></a>基本 AES 加密</h2><p>AES 算法会将纯文本字符串分解为 16 字节的“块”，这些“块”会经过几轮加密。这些步骤在官方<a target="_blank" rel="noopener" href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197.pdf">AES 文档</a>中有详细说明：</p>
<ol>
<li>展开提供的密钥（<strong>密钥扩展[部分</strong>）</li>
<li>使用扩展密钥的明文块上的<strong>AddRoundKey函数</strong></li>
<li>多轮加密<ol>
<li>块上的<strong>SubBytes</strong>功能</li>
<li>块上的<strong>ShiftRows</strong>功能</li>
<li>块上的<strong>MixColumns</strong>功能</li>
<li><strong>AddRoundKey</strong> 函数</li>
</ol>
</li>
<li>最终<strong>SubBytes</strong>调用</li>
<li>最后的 <strong>ShiftRows</strong> 调用</li>
<li>最后的 <strong>AddRoundKey</strong> 调用</li>
</ol>
<p>使用的轮数和扩展密钥<code>EK</code>的大小 取决于所提供密钥的大小。下表显示了密钥长度、轮数和扩展密钥长度之间的相关性：</p>
<table>
<thead>
<tr>
<th align="center"><strong>Key Length (Bits)</strong></th>
<th align="center"><strong>Number of Rounds</strong></th>
<th align="center"><strong>Expanded Key Length (Words)</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">128</td>
<td align="center">10</td>
<td align="center">44</td>
</tr>
<tr>
<td align="center">192</td>
<td align="center">12</td>
<td align="center">72</td>
</tr>
<tr>
<td align="center">256</td>
<td align="center">14</td>
<td align="center">112</td>
</tr>
</tbody></table>
<p>也就是所谓的aes的key的长度，对应的轮数。</p>
<p>key：16位  加密轮数 10轮</p>
<p>key：24位  加密轮数 12轮</p>
<p>key：32位  加密轮数 14轮</p>
<h2 id="AES加密流程"><a href="#AES加密流程" class="headerlink" title="AES加密流程"></a>AES加密流程</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cipher</span>(<span class="params">self, pt</span>):</span><br><span class="line">      <span class="string">&quot;&quot;&quot;Basic AES implementation.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      Args:</span></span><br><span class="line"><span class="string">          pt (bytes): Plaintext to encrypt</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      Returns:</span></span><br><span class="line"><span class="string">          list: Encrypted Ciphertext formatted as list of bytes</span></span><br><span class="line"><span class="string">      &quot;&quot;&quot;</span></span><br><span class="line">      state = self.rows_to_columns(pt)</span><br><span class="line">      self.add_round_key(state, self.ek[<span class="number">0</span>:<span class="number">4</span>]) <span class="comment">#ek is the expanded key</span></span><br><span class="line">      <span class="keyword">for</span> <span class="built_in">round</span> <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">          self.sub_bytes(state)</span><br><span class="line">          self.shift_rows(state)</span><br><span class="line">          self.mix_columns(state)</span><br><span class="line">          self.add_round_key(state, self.ek[<span class="built_in">round</span>*<span class="number">4</span>:(<span class="built_in">round</span>*<span class="number">4</span>)+<span class="number">4</span>])</span><br><span class="line">      self.sub_bytes(state)</span><br><span class="line">      self.shift_rows(state)</span><br><span class="line">      self.add_round_key(state, self.ek[-<span class="number">4</span>:])</span><br><span class="line">      <span class="keyword">return</span> state</span><br></pre></td></tr></table></figure>

<p><img src="/images/pasted-5.png" alt="upload successful"></p>
<p>从这张流程图开始分析。原理就不过多坦述，具体可以看看wiki上的介绍。现在只是加强一下算法特征的认识，</p>
<p>后续逆向过程中，或者开发过程中，好针对性的做出相应措施。</p>
<p>在AES中，每一个状态都会被列为一个4x4的矩阵，也就是明文，密钥等都会被映射到4X4的矩阵中。</p>
<p><img src="/images/pasted-6.png" alt="upload successful"></p>
<p><img src="/images/pasted-7.png" alt="upload successful"></p>
<p>如果长度超出，就会无限往右扩展。。。。</p>
<p>上代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AES::EncryptBlock</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> in[], <span class="type">unsigned</span> <span class="type">char</span> out[],</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">unsigned</span> <span class="type">char</span> *roundKeys)</span> </span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> **state = <span class="keyword">new</span> <span class="type">unsigned</span> <span class="type">char</span> *[<span class="number">4</span>];</span><br><span class="line">  state[<span class="number">0</span>] = <span class="keyword">new</span> <span class="type">unsigned</span> <span class="type">char</span>[<span class="number">4</span> * Nb];</span><br><span class="line">  <span class="type">int</span> i, j, round;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    state[i] = state[<span class="number">0</span>] + Nb * i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; Nb; j++) &#123;</span><br><span class="line">      state[i][j] = in[i + <span class="number">4</span> * j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">AddRoundKey</span>(state, roundKeys);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (round = <span class="number">1</span>; round &lt;= Nr - <span class="number">1</span>; round++) &#123;</span><br><span class="line">    <span class="built_in">SubBytes</span>(state);</span><br><span class="line">    <span class="built_in">ShiftRows</span>(state);</span><br><span class="line">    <span class="built_in">MixColumns</span>(state);</span><br><span class="line">    <span class="built_in">AddRoundKey</span>(state, roundKeys + round * <span class="number">4</span> * Nb);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SubBytes</span>(state);</span><br><span class="line">  <span class="built_in">ShiftRows</span>(state);</span><br><span class="line">  <span class="built_in">AddRoundKey</span>(state, roundKeys + Nr * <span class="number">4</span> * Nb);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; Nb; j++) &#123;</span><br><span class="line">      out[i + <span class="number">4</span> * j] = state[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span>[] state[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">delete</span>[] state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>首先第一步就要对密钥K进行变换扩展。</p>
<p>AES 的扩展密钥是从原始密钥派生的四字节字的列表。数组中的第一个单词与原始键相同。例如，键数组中的前四个字节将是扩展键中的第一个单词，<code>EK</code>，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">key = [0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff]</span><br><span class="line"></span><br><span class="line">expanded_key = [0x00112233,</span><br><span class="line">                0x44556677,</span><br><span class="line">                0x8899aabb,</span><br><span class="line">                0xccddeeff,</span><br><span class="line">                ...]</span><br></pre></td></tr></table></figure>

<p><img src="/images/pasted-8.png" alt="upload successful"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AES::AddRoundKey</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> **state, <span class="type">unsigned</span> <span class="type">char</span> *key)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; Nb; j++) &#123;</span><br><span class="line">      state[i][j] = state[i][j] ^ key[i + <span class="number">4</span> * j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进行n-1轮的循环加密</p>
<ul>
<li><p>subbytes，字节代换，<strong>字节代换层的主要功能就是让输入的数据通过S_box表完成从一个字节到另一个字节的映射，这里的S_box表是通过某种方法计算出来的，具体的计算方法就不介绍了比较复杂，我们基础部分就只给出计算好的S_box结果。</strong></p>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
<th align="center">9</th>
<th align="center">一个</th>
<th align="center">乙</th>
<th align="center">C</th>
<th align="center">D</th>
<th align="center">乙</th>
<th align="center">F</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x63</td>
<td align="center">0x7C</td>
<td align="center">0x77</td>
<td align="center">0x7B</td>
<td align="center">0xF2</td>
<td align="center">0x6B</td>
<td align="center">0x6F</td>
<td align="center">0xC5</td>
<td align="center">0x30</td>
<td align="center">0x01</td>
<td align="center">0x67</td>
<td align="center">0x2B</td>
<td align="center">0xFE</td>
<td align="center">0xD7</td>
<td align="center">0xAB</td>
<td align="center">0x76</td>
</tr>
<tr>
<td align="center">0xCA</td>
<td align="center">0x82</td>
<td align="center">0xC9</td>
<td align="center">0x7D</td>
<td align="center">0xFA</td>
<td align="center">0x59</td>
<td align="center">0x47</td>
<td align="center">0xF0</td>
<td align="center">0xAD</td>
<td align="center">0xD4</td>
<td align="center">0xA2</td>
<td align="center">0xAF</td>
<td align="center">0x9C</td>
<td align="center">0xA4</td>
<td align="center">0x72</td>
<td align="center">0xC0</td>
</tr>
<tr>
<td align="center">0xB7</td>
<td align="center">0xFD</td>
<td align="center">0x93</td>
<td align="center">0x26</td>
<td align="center">0x36</td>
<td align="center">0x3F</td>
<td align="center">0xF7</td>
<td align="center">0xCC</td>
<td align="center">0x34</td>
<td align="center">0xA5</td>
<td align="center">0xE5</td>
<td align="center">0xF1</td>
<td align="center">0x71</td>
<td align="center">0xD8</td>
<td align="center">0x31</td>
<td align="center">0x15</td>
</tr>
<tr>
<td align="center">0x04</td>
<td align="center">0xC7</td>
<td align="center">0x23</td>
<td align="center">0xC3</td>
<td align="center">0x18</td>
<td align="center">0x96</td>
<td align="center">0x05</td>
<td align="center">0x9A</td>
<td align="center">0x07</td>
<td align="center">0x12</td>
<td align="center">0x80</td>
<td align="center">0xE2</td>
<td align="center">0xEB</td>
<td align="center">0x27</td>
<td align="center">0xB2</td>
<td align="center">0x75</td>
</tr>
<tr>
<td align="center">0x09</td>
<td align="center">0x83</td>
<td align="center">0x2C</td>
<td align="center">0x1A</td>
<td align="center">0x1B</td>
<td align="center">0x6E</td>
<td align="center">0x5A</td>
<td align="center">0xA0</td>
<td align="center">0x52</td>
<td align="center">0x3B</td>
<td align="center">0xD6</td>
<td align="center">0xB3</td>
<td align="center">0x29</td>
<td align="center">0xE3</td>
<td align="center">0x2F</td>
<td align="center">0x84</td>
</tr>
<tr>
<td align="center">0x53</td>
<td align="center">0xD1</td>
<td align="center">0x00</td>
<td align="center">0xED</td>
<td align="center">0x20</td>
<td align="center">0xFC</td>
<td align="center">0xB1</td>
<td align="center">0x5B</td>
<td align="center">0x6A</td>
<td align="center">0xCB</td>
<td align="center">0xBE</td>
<td align="center">0x39</td>
<td align="center">0x4A</td>
<td align="center">0x4C</td>
<td align="center">0x58</td>
<td align="center">0xCF</td>
</tr>
<tr>
<td align="center">0xD0</td>
<td align="center">0xEF</td>
<td align="center">0xAA</td>
<td align="center">0xFB</td>
<td align="center">0x43</td>
<td align="center">0x4D</td>
<td align="center">0x33</td>
<td align="center">0x85</td>
<td align="center">0x45</td>
<td align="center">0xF9</td>
<td align="center">0x02</td>
<td align="center">0x7F</td>
<td align="center">0x50</td>
<td align="center">0x3C</td>
<td align="center">0x9F</td>
<td align="center">0xA8</td>
</tr>
<tr>
<td align="center">0x51</td>
<td align="center">0xA3</td>
<td align="center">0x40</td>
<td align="center">0x8F</td>
<td align="center">0x92</td>
<td align="center">0x9D</td>
<td align="center">0x38</td>
<td align="center">0xF5</td>
<td align="center">0xBC</td>
<td align="center">0xB6</td>
<td align="center">0xDA</td>
<td align="center">0x21</td>
<td align="center">0x10</td>
<td align="center">0xFF</td>
<td align="center">0xF3</td>
<td align="center">0xD2</td>
</tr>
<tr>
<td align="center">0xCD</td>
<td align="center">0x0C</td>
<td align="center">0x13</td>
<td align="center">0xEC</td>
<td align="center">0x5F</td>
<td align="center">0x97</td>
<td align="center">0x44</td>
<td align="center">0x17</td>
<td align="center">0xC4</td>
<td align="center">0xA7</td>
<td align="center">0x7E</td>
<td align="center">0x3D</td>
<td align="center">0x64</td>
<td align="center">0x5D</td>
<td align="center">0x19</td>
<td align="center">0x73</td>
</tr>
<tr>
<td align="center">0x60</td>
<td align="center">0x81</td>
<td align="center">0x4F</td>
<td align="center">0xDC</td>
<td align="center">0x22</td>
<td align="center">0x2A</td>
<td align="center">0x90</td>
<td align="center">0x88</td>
<td align="center">0x46</td>
<td align="center">0xEE</td>
<td align="center">0xB8</td>
<td align="center">0x14</td>
<td align="center">0xDE</td>
<td align="center">0x5E</td>
<td align="center">0x0B</td>
<td align="center">0xDB</td>
</tr>
<tr>
<td align="center">0xE0</td>
<td align="center">0x32</td>
<td align="center">0x3A</td>
<td align="center">0x0A</td>
<td align="center">0x49</td>
<td align="center">0x06</td>
<td align="center">0x24</td>
<td align="center">0x5C</td>
<td align="center">0xC2</td>
<td align="center">0xD3</td>
<td align="center">0xAC</td>
<td align="center">0x62</td>
<td align="center">0x91</td>
<td align="center">0x95</td>
<td align="center">0xE4</td>
<td align="center">0x79</td>
</tr>
<tr>
<td align="center">0xE7</td>
<td align="center">0xC8</td>
<td align="center">0x37</td>
<td align="center">0x6D</td>
<td align="center">0x8D</td>
<td align="center">0xD5</td>
<td align="center">0x4E</td>
<td align="center">0xA9</td>
<td align="center">0x6C</td>
<td align="center">0x56</td>
<td align="center">0xF4</td>
<td align="center">0xEA</td>
<td align="center">0x65</td>
<td align="center">0x7A</td>
<td align="center">0xAE</td>
<td align="center">0x08</td>
</tr>
<tr>
<td align="center">0xBA</td>
<td align="center">0x78</td>
<td align="center">0x25</td>
<td align="center">0x2E</td>
<td align="center">0x1C</td>
<td align="center">0xA6</td>
<td align="center">0xB4</td>
<td align="center">0xC6</td>
<td align="center">0xE8</td>
<td align="center">0xDD</td>
<td align="center">0x74</td>
<td align="center">0x1F</td>
<td align="center">0x4B</td>
<td align="center">0xBD</td>
<td align="center">0x8B</td>
<td align="center">0x8A</td>
</tr>
<tr>
<td align="center">0x70</td>
<td align="center">0x3E</td>
<td align="center">0xB5</td>
<td align="center">0x66</td>
<td align="center">0x48</td>
<td align="center">0x03</td>
<td align="center">0xF6</td>
<td align="center">0x0E</td>
<td align="center">0x61</td>
<td align="center">0x35</td>
<td align="center">0x57</td>
<td align="center">0xB9</td>
<td align="center">0x86</td>
<td align="center">0xC1</td>
<td align="center">0x1D</td>
<td align="center">0x9E</td>
</tr>
<tr>
<td align="center">0xE1</td>
<td align="center">0xF8</td>
<td align="center">0x98</td>
<td align="center">0x11</td>
<td align="center">0x69</td>
<td align="center">0xD9</td>
<td align="center">0x8E</td>
<td align="center">0x94</td>
<td align="center">0x9B</td>
<td align="center">0x1E</td>
<td align="center">0x87</td>
<td align="center">0xE9</td>
<td align="center">0xCE</td>
<td align="center">0x55</td>
<td align="center">0x28</td>
<td align="center">0xDF</td>
</tr>
<tr>
<td align="center">0x8C</td>
<td align="center">0xA1</td>
<td align="center">0x89</td>
<td align="center">0x0D</td>
<td align="center">0xBF</td>
<td align="center">0xE6</td>
<td align="center">0x42</td>
<td align="center">0x68</td>
<td align="center">0x41</td>
<td align="center">0x99</td>
<td align="center">0x2D</td>
<td align="center">0x0F</td>
<td align="center">0xB0</td>
<td align="center">0x54</td>
<td align="center">0xBB</td>
<td align="center">0x16</td>
</tr>
</tbody></table>
</li>
</ul>
<p>逆SBOX自己github找找就行。</p>
<p><img src="/images/pasted-10.png" alt="upload successful"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AES::SubBytes</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> **state)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> t;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; Nb; j++) &#123;</span><br><span class="line">      t = state[i][j];</span><br><span class="line">      state[i][j] = sbox[t / <span class="number">16</span>][t % <span class="number">16</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>ShiftRows行位移，<strong>行位移操作最为简单，它是用来将输入数据作为一个4·4的字节矩阵进行处理的，然后将这个矩阵的字节进行位置上的置换。ShiftRows子层属于AES手动的扩散层，目的是将单个位上的变换扩散到影响整个状态当，从而达到雪崩效应。在加密时行位移处理与解密时的处理相反，我们这里将解密时的处理称作逆行位移。它之所以称作行位移，是因为它只在4·4矩阵的行间进行操作，每行4字节的数据。在加密时，保持矩阵的第一行不变，第二行向左移动8Bit(一个字节)、第三行向左移动2个字节、第四行向左移动3个字节。而在解密时恰恰相反，依然保持第一行不变，将第二行向右移动一个字节、第三行右移2个字节、第四行右移3个字节。操作结束！</strong></li>
</ul>
<p><img src="/images/pasted-11.png" alt="upload successful"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AES::ShiftRow</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> **state, <span class="type">int</span> i,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">int</span> n)</span>  <span class="comment">// shift row i on n positions</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> *tmp = <span class="keyword">new</span> <span class="type">unsigned</span> <span class="type">char</span>[Nb];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; Nb; j++) &#123;</span><br><span class="line">    tmp[j] = state[i][(j + n) % Nb];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memcpy</span>(state[i], tmp, Nb * <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span>[] tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AES::ShiftRows</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> **state)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">ShiftRow</span>(state, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">ShiftRow</span>(state, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">ShiftRow</span>(state, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>Mixcolums列混淆,MixColumns 将对状态中的每一列执行矩阵乘法。这里的乘法也像 Key Expansion 函数一样使用伽罗瓦域。我设法从用户<a target="_blank" rel="noopener" href="https://gist.github.com/lovasoa/a0b384ca0e9c0a485f212caab68d98ec#file-aes-py-L121"> lovasoa</a>的 GitHub 中找到了该算法的纯 Python 实现，如下所示：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gmul</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Special AES function used for multiplication</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        a (int): Integer to multiply</span></span><br><span class="line"><span class="string">        b (int): Integer to multiply</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        int: The product of the values</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    p = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        <span class="keyword">if</span> b &amp; <span class="number">1</span>:</span><br><span class="line">            p ^= a</span><br><span class="line">        a &lt;&lt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> a &amp; <span class="number">0x100</span>:</span><br><span class="line">            a ^= <span class="number">0x11b</span></span><br><span class="line">        b &gt;&gt;= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure>

<p>矩阵乘法如下所示：</p>
<p>整个函数可以显示为以下 Python 代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mix_columns</span>(<span class="params">self, state</span>):</span><br><span class="line">      <span class="string">&quot;&quot;&quot;AES MixColumns Method.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      Args:</span></span><br><span class="line"><span class="string">          state (list): AES State</span></span><br><span class="line"><span class="string">      &quot;&quot;&quot;</span></span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">          a = state[i]</span><br><span class="line">          b = state[i+<span class="number">4</span>]</span><br><span class="line">          c = state[i+<span class="number">8</span>]</span><br><span class="line">          d = state[i+<span class="number">12</span>]</span><br><span class="line">          state[i] = gmul(<span class="number">2</span>, a) ^ gmul(<span class="number">3</span>, b) ^ c ^ d</span><br><span class="line">          state[i+<span class="number">4</span>] = a ^ gmul(<span class="number">2</span>, b) ^ gmul(<span class="number">3</span>, c) ^ d</span><br><span class="line">          state[i+<span class="number">8</span>] = a ^ b ^ gmul(<span class="number">2</span>, c) ^ gmul(<span class="number">3</span>, d)</span><br><span class="line">          state[i+<span class="number">12</span>] = gmul(<span class="number">3</span>, a) ^ b ^ c ^ gmul(<span class="number">2</span>, d)</span><br></pre></td></tr></table></figure>



<p><img src="/images/pasted-12.png" alt="upload successful"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AES::MixColumns</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> **state)</span> </span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> temp_state[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(temp_state[i], <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (CMDS[i][k] == <span class="number">1</span>)</span><br><span class="line">          temp_state[i][j] ^= state[k][j];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          temp_state[i][j] ^= GF_MUL_TABLE[CMDS[i][k]][state[k][j]];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(state[i], temp_state[i], <span class="number">4</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>AddRoundKey加固键，AES 中的 AddRoundKey 函数将通过状态的每一列对扩展密钥的一部分进行异或。</li>
</ul>
<p><img src="/images/pasted-13.png" alt="upload successful"></p>
<p>最后一轮：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SubBytes</span>(state);</span><br><span class="line"><span class="built_in">ShiftRows</span>(state);</span><br><span class="line"><span class="built_in">AddRoundKey</span>(state, roundKeys + Nr * <span class="number">4</span> * Nb);</span><br></pre></td></tr></table></figure>



<h2 id="AEST表"><a href="#AEST表" class="headerlink" title="AEST表"></a>AEST表</h2><p>这个表示干嘛的呢，一张图显示。</p>
<p><img src="/images/pasted-14.png" alt="upload successful"></p>
<p>有时候在逆向的时候，往往会出现很多这样的表，一般都是4张左右，都是sbox生成的加速表，用来加速aes加解密计算的。</p>
<h3 id="AES-查找表-T-Table-方法"><a href="#AES-查找表-T-Table-方法" class="headerlink" title="AES 查找表 (T-Table) 方法"></a>AES 查找表 (T-Table) 方法</h3><p>为了提高 AES 算法的效率，MixColumns、ShiftRows 和 SubBytes 函数被组合成一个使用五个查找表的操作。密钥扩展算法与原始 AES 算法相同，状态被视为普通数组而不是 4x4 矩阵。</p>
<h3 id="查找表生成"><a href="#查找表生成" class="headerlink" title="查找表生成"></a>查找表生成</h3><p>前四个查找表 (T-Tables) 是通过将 S-Box 的每个字节乘以 MixColumns 函数中使用的矩阵来生成的。这将创建四个包含 256 个四字节字的表。它们可以使用以下算法生成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T1 = &#123;S[i] * 2, S[i], S[i], S[i] * 3&#125;</span><br><span class="line">T2 = &#123;S[i] * 3, S[i] * 2, S[i], S[i]&#125;</span><br><span class="line">T3 = &#123;S[i], S[i] *  3, S[i] * 2, S[i]&#125;</span><br><span class="line">T4 = &#123;S[i], S[i], S[i] * 3, S[i] * 2&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/pasted-15.png" alt="upload successful"></p>
<p>最终的 T-Table 将 S-Box 的每个字节组合成一个四字节的字，并且仅在最后一轮加密期间使用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Final T-Table generation</span><br><span class="line">T5 = &#123;S[i], S[i], S[i], S[i]&#125;</span><br></pre></td></tr></table></figure>

<p>查找表的整个生成过程可能类似于以下 Python 代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generate_t_tables</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Generates the tables used for the AES lookup table method.&quot;&quot;&quot;</span></span><br><span class="line">    self.t1 = []</span><br><span class="line">    self.t2 = []</span><br><span class="line">    self.t3 = []</span><br><span class="line">    self.t4 = []</span><br><span class="line">    self.t5 = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.SBOX)):</span><br><span class="line">        word1 = [gmul(self.SBOX[i], <span class="number">2</span>), self.SBOX[i],</span><br><span class="line">                 self.SBOX[i], gmul(self.SBOX[i], <span class="number">3</span>)]</span><br><span class="line">        word2 = [gmul(self.SBOX[i], <span class="number">3</span>), gmul(self.SBOX[i], <span class="number">2</span>),</span><br><span class="line">                 self.SBOX[i], self.SBOX[i]]</span><br><span class="line">        word3 = [self.SBOX[i], gmul(self.SBOX[i], <span class="number">3</span>),</span><br><span class="line">                 gmul(self.SBOX[i], <span class="number">2</span>), self.SBOX[i]]</span><br><span class="line">        word4 = [self.SBOX[i], self.SBOX[i],</span><br><span class="line">                 gmul(self.SBOX[i], <span class="number">3</span>), gmul(self.SBOX[i], <span class="number">2</span>)]</span><br><span class="line">        word5 = [self.SBOX[i]] * <span class="number">4</span></span><br><span class="line">        self.t1.append(struct.unpack(<span class="string">&#x27;&gt;I&#x27;</span>, <span class="built_in">bytes</span>(word1))[<span class="number">0</span>])</span><br><span class="line">        self.t2.append(struct.unpack(<span class="string">&#x27;&gt;I&#x27;</span>, <span class="built_in">bytes</span>(word2))[<span class="number">0</span>])</span><br><span class="line">        self.t3.append(struct.unpack(<span class="string">&#x27;&gt;I&#x27;</span>, <span class="built_in">bytes</span>(word3))[<span class="number">0</span>])</span><br><span class="line">        self.t4.append(struct.unpack(<span class="string">&#x27;&gt;I&#x27;</span>, <span class="built_in">bytes</span>(word4))[<span class="number">0</span>])</span><br><span class="line">        self.t5.append(struct.unpack(<span class="string">&#x27;&gt;I&#x27;</span>, <span class="built_in">bytes</span>(word5))[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<h3 id="回合加密"><a href="#回合加密" class="headerlink" title="回合加密"></a>回合加密</h3><p>对于每一轮加密，AES T-Table 算法将对原始明文数组索引处的四个查找表的一个字节进行异或。例如，一个普通的回合看起来像下面的伪代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">A[<span class="number">0</span>] = PT[<span class="number">0</span>:<span class="number">4</span>] ^ W[<span class="number">0</span>]</span><br><span class="line">A[<span class="number">1</span>] = PT[<span class="number">4</span>:<span class="number">8</span>] ^ W[<span class="number">1</span>]</span><br><span class="line">A[<span class="number">2</span>] = PT[<span class="number">8</span>:<span class="number">12</span>] ^ W[<span class="number">2</span>]</span><br><span class="line">A[<span class="number">3</span>] = PT[<span class="number">12</span>:<span class="number">16</span>] ^ W[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">K = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> round in NUM_ROUNDS:</span><br><span class="line">  S[<span class="number">0</span>:<span class="number">4</span>] = A[<span class="number">0</span>] # Convert word to bytes</span><br><span class="line">  S[<span class="number">4</span>:<span class="number">8</span>] = A[<span class="number">1</span>]</span><br><span class="line">  S[<span class="number">8</span>:<span class="number">12</span>] = A[<span class="number">2</span>]</span><br><span class="line">  S[<span class="number">12</span>:<span class="number">16</span>] = A[<span class="number">3</span>]</span><br><span class="line">  A[<span class="number">0</span>] = T1[S[<span class="number">0</span>]] ^ T2[S[<span class="number">5</span>]] ^ T3[S[<span class="number">10</span>]] ^ T4[S[<span class="number">15</span>]] ^ W[K+<span class="number">0</span>]</span><br><span class="line">  A[<span class="number">1</span>] = T1[S[<span class="number">4</span>]] ^ T2[S[<span class="number">9</span>]] ^ T3[S[<span class="number">14</span>]] ^ T4[S[<span class="number">3</span>]] ^ W[K+<span class="number">1</span>]</span><br><span class="line">  A[<span class="number">2</span>] = T1[S[<span class="number">8</span>]] ^ T2[S[<span class="number">13</span>]] ^ T3[S[<span class="number">2</span>]] ^ T4[S[<span class="number">7</span>]] ^ W[K+<span class="number">2</span>]</span><br><span class="line">  A[<span class="number">3</span>] = T1[S[<span class="number">12</span>]] ^ T2[S[<span class="number">1</span>]] ^ T3[S[<span class="number">6</span>]] ^ T4[S[<span class="number">11</span>]] ^ W[K+<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>此方法比调用单独的 SubBytes、ShiftRows 和 MixColumns 函数更有效，因为它是一步完成的。一次组合所有方法时，无需执行多个循环或函数调用。</p>
<h3 id="最后一轮"><a href="#最后一轮" class="headerlink" title="最后一轮"></a>最后一轮</h3><p>最后一轮加密类似于普通轮，除了它使用第五个 T-Table 并且每个 XOR 都附加到密文中。下面的伪代码演示了这个过程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CT[<span class="number">0</span>:<span class="number">4</span>] = T5[S[<span class="number">0</span>]] ^ T5[S[<span class="number">5</span>]] ^ T5[S[<span class="number">10</span>]] ^ T5[S[<span class="number">15</span>]] ^ W[K+<span class="number">0</span>]</span><br><span class="line">CT[<span class="number">4</span>:<span class="number">8</span>] = T5[S[<span class="number">4</span>]] ^ T5[S[<span class="number">9</span>]] ^ T5[S[<span class="number">14</span>]] ^ T5[S[<span class="number">3</span>]] ^ W[K+<span class="number">1</span>]</span><br><span class="line">CT[<span class="number">8</span>:<span class="number">12</span>] = T5[S[<span class="number">8</span>]] ^ T5[S[<span class="number">13</span>]] ^ T5[S[<span class="number">2</span>]] ^ T5[S[<span class="number">7</span>]] ^ W[K+<span class="number">2</span>]</span><br><span class="line">CT[<span class="number">12</span>:<span class="number">16</span>] = T5[S[<span class="number">12</span>]] ^ T5[S[<span class="number">1</span>]] ^ T5[S[<span class="number">6</span>]] ^ T5[S[<span class="number">11</span>]] ^ W[K+<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<h3 id="AES-T-表-Python-代码"><a href="#AES-T-表-Python-代码" class="headerlink" title="AES T 表 Python 代码"></a>AES T 表 Python 代码</h3><p>AES T-Table 实现的完整代码如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">cipher_t_table</span><span class="params">(self, pt)</span>:</span></span><br><span class="line"><span class="function">    <span class="string">&quot;&quot;</span><span class="string">&quot;Lookup Table AES implementation.</span></span></span><br><span class="line"><span class="string"><span class="function"></span></span></span><br><span class="line"><span class="string"><span class="function">    Args:</span></span></span><br><span class="line"><span class="string"><span class="function">        pt (bytes): Plaintext to encrypt</span></span></span><br><span class="line"><span class="string"><span class="function"></span></span></span><br><span class="line"><span class="string"><span class="function">    Returns:</span></span></span><br><span class="line"><span class="string"><span class="function">        bytes: Encrypted Ciphertext</span></span></span><br><span class="line"><span class="string"><span class="function">    &quot;</span><span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="function">    ct =</span> []</span><br><span class="line">    a = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    <span class="meta"># t is a temporary array to avoid us changing array a while performing the algorithm</span></span><br><span class="line">    t = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    a[<span class="number">0</span>] = <span class="keyword">struct</span>.<span class="built_in">unpack</span>(<span class="string">&#x27;&gt;I&#x27;</span>, pt[<span class="number">0</span>:<span class="number">4</span>])[<span class="number">0</span>] ^ self.ek[<span class="number">0</span>]</span><br><span class="line">    a[<span class="number">1</span>] = <span class="keyword">struct</span>.<span class="built_in">unpack</span>(<span class="string">&#x27;&gt;I&#x27;</span>, pt[<span class="number">4</span>:<span class="number">8</span>])[<span class="number">0</span>] ^ self.ek[<span class="number">1</span>]</span><br><span class="line">    a[<span class="number">2</span>] = <span class="keyword">struct</span>.<span class="built_in">unpack</span>(<span class="string">&#x27;&gt;I&#x27;</span>, pt[<span class="number">8</span>:<span class="number">12</span>])[<span class="number">0</span>] ^ self.ek[<span class="number">2</span>]</span><br><span class="line">    a[<span class="number">3</span>] = <span class="keyword">struct</span>.<span class="built_in">unpack</span>(<span class="string">&#x27;&gt;I&#x27;</span>, pt[<span class="number">12</span>:<span class="number">16</span>])[<span class="number">0</span>] ^ self.ek[<span class="number">3</span>]</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="keyword">for</span> round in <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">        <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            # Using binary rotation instead of splitting words into array</span><br><span class="line">            t[i] = (self.t1[(a[i] &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>] ^</span><br><span class="line">                    self.t2[(a[(i + <span class="number">1</span>) % <span class="number">4</span>] &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>] ^</span><br><span class="line">                    self.t3[(a[(i + <span class="number">2</span>) % <span class="number">4</span>] &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>] ^</span><br><span class="line">                    self.t4[(a[(i + <span class="number">3</span>) % <span class="number">4</span>]) &amp; <span class="number">0xff</span>] ^</span><br><span class="line">                    self.ek[(round*<span class="number">4</span>)+i])</span><br><span class="line">        a = t.<span class="built_in">copy</span>()</span><br><span class="line"></span><br><span class="line">    # Final round of encryption</span><br><span class="line">    <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        ct.<span class="built_in">append</span>(self.SBOX[(a[i] &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>] ^</span><br><span class="line">                  ((self.ek[<span class="number">-4</span>+i] &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>))</span><br><span class="line">        ct.<span class="built_in">append</span>(self.SBOX[(a[(i + <span class="number">1</span>) % <span class="number">4</span>] &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>] ^</span><br><span class="line">                  ((self.ek[<span class="number">-4</span>+i] &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>))</span><br><span class="line">        ct.<span class="built_in">append</span>(self.SBOX[(a[(i + <span class="number">2</span>) % <span class="number">4</span>] &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>] ^</span><br><span class="line">                  ((self.ek[<span class="number">-4</span>+i] &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>))</span><br><span class="line">        ct.<span class="built_in">append</span>(self.SBOX[(a[(i + <span class="number">3</span>) % <span class="number">4</span>]) &amp; <span class="number">0xff</span>] ^</span><br><span class="line">                  ((self.ek[<span class="number">-4</span>+i]) &amp; <span class="number">0xff</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(ct)</span><br></pre></td></tr></table></figure>



<h2 id="AES分析和魔改"><a href="#AES分析和魔改" class="headerlink" title="AES分析和魔改"></a>AES分析和魔改</h2>
  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/secguide/">移动安全</a></li>
         
          <li><a target="_blank" rel="noopener" href="http://github.com/chionyuan">项目</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#MD5"><span class="toc-number">1.</span> <span class="toc-text">MD5</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.0.1.</span> <span class="toc-text">散列函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MD5%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.</span> <span class="toc-text">MD5算法原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%A1%AB%E5%85%85%E4%BF%A1%E6%81%AF"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.填充信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86"><span class="toc-number">1.1.2.</span> <span class="toc-text">2.信息处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#md5%E7%AE%97%E6%B3%95%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">md5算法过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MD5%E5%88%86%E6%9E%90%E5%92%8C%E9%AD%94%E6%94%B9"><span class="toc-number">1.3.</span> <span class="toc-text">MD5分析和魔改</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#md5%E4%BF%AE%E6%94%B9%E7%82%B9"><span class="toc-number">1.4.</span> <span class="toc-text">md5修改点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AES"><span class="toc-number">2.</span> <span class="toc-text">AES</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC-AES-%E5%8A%A0%E5%AF%86"><span class="toc-number">2.1.</span> <span class="toc-text">基本 AES 加密</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AES%E5%8A%A0%E5%AF%86%E6%B5%81%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">AES加密流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AEST%E8%A1%A8"><span class="toc-number">2.3.</span> <span class="toc-text">AEST表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AES-%E6%9F%A5%E6%89%BE%E8%A1%A8-T-Table-%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.1.</span> <span class="toc-text">AES 查找表 (T-Table) 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E8%A1%A8%E7%94%9F%E6%88%90"><span class="toc-number">2.3.2.</span> <span class="toc-text">查找表生成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E5%90%88%E5%8A%A0%E5%AF%86"><span class="toc-number">2.3.3.</span> <span class="toc-text">回合加密</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%90%8E%E4%B8%80%E8%BD%AE"><span class="toc-number">2.3.4.</span> <span class="toc-text">最后一轮</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AES-T-%E8%A1%A8-Python-%E4%BB%A3%E7%A0%81"><span class="toc-number">2.3.5.</span> <span class="toc-text">AES T 表 Python 代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AES%E5%88%86%E6%9E%90%E5%92%8C%E9%AD%94%E6%94%B9"><span class="toc-number">2.4.</span> <span class="toc-text">AES分析和魔改</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://chionyuan.github.io/2022/07/19/common-algorithm/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://chionyuan.github.io/2022/07/19/common-algorithm/&text=通用加密算法解析和魔改"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://chionyuan.github.io/2022/07/19/common-algorithm/&title=通用加密算法解析和魔改"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://chionyuan.github.io/2022/07/19/common-algorithm/&is_video=false&description=通用加密算法解析和魔改"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=通用加密算法解析和魔改&body=Check out this article: http://chionyuan.github.io/2022/07/19/common-algorithm/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://chionyuan.github.io/2022/07/19/common-algorithm/&title=通用加密算法解析和魔改"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://chionyuan.github.io/2022/07/19/common-algorithm/&title=通用加密算法解析和魔改"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://chionyuan.github.io/2022/07/19/common-algorithm/&title=通用加密算法解析和魔改"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://chionyuan.github.io/2022/07/19/common-algorithm/&title=通用加密算法解析和魔改"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://chionyuan.github.io/2022/07/19/common-algorithm/&name=通用加密算法解析和魔改&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://chionyuan.github.io/2022/07/19/common-algorithm/&t=通用加密算法解析和魔改"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2022
    chionyuan
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/secguide/">移动安全</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/chionyuan">项目</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
